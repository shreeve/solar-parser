// ES6 Parser generated by Solar 1.0.8
const hasProp = {}.hasOwnProperty

const parserInstance = {
  symbolIds: {"$accept":0,"$end":1,"error":2,"Program":3,"Expression":4,"NUMBER":5,"+":6,"-":7,"*":8,"/":9,"(":10,")":11},
  tokenNames: {2:"error",5:"NUMBER",6:"+",7:"-",8:"*",9:"/",10:"(",11:")"},
  ruleData: [[0],[3,1],[4,1],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2]],
  parseTable: [{3:1,4:2,5:[1,3],7:[1,5],10:[1,4]},{1:[3]},{1:[2,1],6:[1,6],7:[1,7],8:[1,8],9:[1,9]},{1:[2,2],6:[2,2],7:[2,2],8:[2,2],9:[2,2],11:[2,2]},{4:10,5:[1,3],7:[1,5],10:[1,4]},{4:11,5:[1,3],7:[1,5],10:[1,4]},{4:12,5:[1,3],7:[1,5],10:[1,4]},{4:13,5:[1,3],7:[1,5],10:[1,4]},{4:14,5:[1,3],7:[1,5],10:[1,4]},{4:15,5:[1,3],7:[1,5],10:[1,4]},{6:[1,6],7:[1,7],8:[1,8],9:[1,9],11:[1,16]},{1:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],11:[2,8]},{1:[2,3],6:[2,3],7:[2,3],8:[1,8],9:[1,9],11:[2,3]},{1:[2,4],6:[2,4],7:[2,4],8:[1,8],9:[1,9],11:[2,4]},{1:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],11:[2,5]},{1:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],11:[2,6]},{1:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],11:[2,7]}],
  defaultActions: {},
  performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
const $0 = $$.length - 1;
switch (yystate) {
  case 1: case 2: return $$[$0];
  case 3: return ["+", $$[$0-2], $$[$0]];
  case 4: return ["-", $$[$0-2], $$[$0]];
  case 5: return ["*", $$[$0-2], $$[$0]];
  case 6: return ["/", $$[$0-2], $$[$0]];
  case 7: return $$[$0-1];
  case 8: return ["-", $$[$0]];
}
},
  parseError(str, hash) {
    if (hash.recoverable)
      this.trace(str);
    else {
      const line = (hash.line || 0) + 1, col = hash.loc?.first_column || 0, token = hash.token ? ` (token: ${hash.token})` : "", text = hash.text ? ` near '${hash.text}'` : "", message = `Parse error at ${`line ${line}, column ${col}`}${token}${text}: ${str}`, error = Error(message);
      error.hash = hash;
      throw error;
    }
  },
  parse(input) {
    const stk = [0], val = [null], loc = [], { parseTable } = this;
    let yytext = "", yylineno = 0, yyleng = 0, recovering = 0;
    const [TERROR, EOF] = [2, 1], lexer = Object.create(this.lexer), sharedState = { yy: {} };
    for (const k in this.yy)
      if (Object.hasOwn(this.yy, k))
        sharedState.yy[k] = this.yy[k];
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (!lexer.yylloc)
      lexer.yylloc = {};
    let yyloc = lexer.yylloc;
    loc.push(yyloc);
    const ranges = lexer.options?.ranges;
    this.parseError = typeof sharedState.yy.parseError === "function" ? sharedState.yy.parseError : Object.getPrototypeOf(this).parseError;
    const lex = () => {
      let token = lexer.lex() || EOF;
      if (typeof token !== "number")
        token = this.symbolIds[token] || token;
      return token;
    };
    let symbol = null, preErrorSymbol = null, state, action, r;
    const yyval = {};
    let p, len, newState, expected = null;
    while (!0) {
      state = stk.at(-1);
      action = this.defaultActions[state] || (symbol == null && (symbol = lex()), parseTable[state]?.[symbol]);
      if (!(action?.length && action[0])) {
        let errStr = "";
        if (!recovering) {
          expected = [];
          for (const p in parseTable[state]) {
            const pNum = Number(p);
            if (Object.hasOwn(parseTable[state], p) && this.tokenNames[pNum] && pNum > TERROR)
              expected.push(`'${this.tokenNames[pNum]}'`);
          }
        }
        errStr = lexer.showPosition ? `Parse error on line ${yylineno + 1}:
${lexer.showPosition()}
Expecting ${expected?.join(", ")}, got '${this.tokenNames[symbol] || symbol}'` : `Parse error on line ${yylineno + 1}: Unexpected ${symbol === EOF ? "end of input" : `'${this.tokenNames[symbol] || symbol}'`}`;
        this.parseError(errStr, {
          text: lexer.match,
          token: this.tokenNames[symbol] || symbol || void 0,
          line: lexer.yylineno,
          loc: yyloc,
          expected: expected || void 0
        });
        throw Error(errStr);
      }
      if (Array.isArray(action[0]) && action.length > 1)
        throw Error(`Parse Error: multiple actions possible at state: ${state}, token: ${symbol}`);
      switch (action[0]) {
        case 1:
          stk.push(symbol, action[1]);
          val.push(lexer.yytext);
          loc.push(lexer.yylloc);
          symbol = null;
          if (!preErrorSymbol) {
            yyleng = lexer.yyleng;
            yytext = lexer.yytext;
            yylineno = lexer.yylineno;
            yyloc = lexer.yylloc;
            if (recovering > 0)
              recovering--;
          } else {
            symbol = preErrorSymbol;
            preErrorSymbol = null;
          }
          break;
        case 2:
          len = this.ruleData[action[1]][1];
          yyval.$ = val[val.length - len];
          const locFirst = loc[loc.length - (len || 1)], locLast = loc.at(-1);
          yyval._$ = {
            first_line: locFirst.first_line,
            last_line: locLast.last_line,
            first_column: locFirst.first_column,
            last_column: locLast.last_column
          };
          if (ranges)
            yyval._$.range = [locFirst.range[0], locLast.range[1]];
          const performActionFn = eval(`(${this.performAction})`);
          r = performActionFn.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], val, loc]);
          if (r != null)
            yyval.$ = r;
          if (len) {
            stk.length -= len * 2;
            val.length -= len;
            loc.length -= len;
          }
          stk.push(this.ruleData[action[1]][0]);
          val.push(yyval.$);
          loc.push(yyval._$);
          newState = parseTable[stk.at(-2)][stk.at(-1)];
          stk.push(newState);
          break;
        case 3:
          return val.at(-1);
      }
    }
  },
  trace() {},
  yy: {},
}

function createParser(yyInit = {}) {
  const p = Object.create(parserInstance);
  Object.defineProperty(p, "yy", {
    value: { ...yyInit },
    enumerable: false,
    writable: true,
    configurable: true,
  })
  return p
}

const parser = /*#__PURE__*/createParser()

export { parser }
export const Parser = createParser
export const parse = parser.parse.bind(parser)
export default parser
